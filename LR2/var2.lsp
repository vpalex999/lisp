#|
Вариант 2
1. Определите функцию, обращающую список и все его подсписки
на любом уровне, например, (a b (c d) e) -> (e (d c) b a).


revers_s '() nil
NIL

revers_s '(1) nil
(1)

revers_s '(1 2) nil
(2 1)

revers_s '(1 (2 3) 4) nil
(4 (3 2) 1)

|#

(defun f1(s)
    (labels
        (
            (revers_s(s u) ; ф-я обращает список и накапливает его в аккумуляторе u.
                (cond
                    ((null s) u) ; проход по списку s до конца -> возвращаем аккумулятор (обращённый список)
                    ((listp (first s)) ; если есть подсписок
                        (revers_s (rest s) (cons (revers_s (first s) nil) u) ) ; обращаем и складываем с аккумулятором
                    )
                    (t (revers_s (rest s)(cons (first s) u))) ; проход в цикле по s, обращаем список
                )
            )
        )
        (revers_s s nil)
    )
)




#|
2. Напишите функцию, заменяющую Y на число, равное глубине
вложения Y в W, например, Y=a, W=((a b) a (c (a (a d)))) ->
((2 b) 1 (c (3 (4 d)))).

f2 'a '()
()

f2 'a '(b)
(b)

f2 'a '(a b)
(1 b)

f2 '(a b a)
(1 b 1)

f2 'a '(a (b a))
(1 (b 2))

|#

(defun f2(y w)
    (cond
        ((null w) nil)          ; граничное значение - пустой список
        (t (replace_el y w 1))  ; вспомогательная ф-я с накапливанием уровня вложенности.
    )
)

#|
replace_el 'a () 1
()

replace_el 'a '(b) 1
(b)

replace_el 'a '(a) 1
(1)

replace_el 'a '(a b a) 1
(1 b 1)

replace_el 'a ((a)) 1
((2))

replace_el 'a '(a (b a) c a) 1
(1 (b 2) c 1)

|#

; вспомогательная ф-я с накапливанием уровня вложенности.
(defun replace_el(y w level)

    (cond 
        ((null w) nil)      ; граничное значение, выхода из цикла - пустой список.
        ((listp (first w))  ; если первый эл-т - является списком:
            (cons (replace_el y (first w) (+ 1 level)) ; первый эл-т (обрабатываем как подсписок, инкрементируем уровень вложенности) и
                  (replace_el y (rest w) level)        ; складываем с обработанным хвостом, уровень вложенности - не меняем.
            ))
        ((eq y (first w))   ; если первый эл-т == y:
            (cons level (replace_el y (rest w) level))) ; меняем эл-т на уровень вложенности level и складываем с обработанным хвостом, уровень вложенности - не меняем.   
        (t (cons (first w) (replace_el y (rest w) level)))  ; иначе - продолжаем цикл ничего не меняя.
    )
)


#|
3. Напишите функцию, единственным аргументом которой являлся бы
список списков, объединяющую все эти списки в один.
f3 '()
NIL

f3 '(a b)
(a b)

f3 '((a))
(a)

f3 '((a) (b) (c) d)
(a b c d)

|#

(defun f3 (s)
    (cond
     ; пустой список - граничное значение, конец цикла
     ((null s) nil)
     ; если первый эл-т -список, то объединяем список с хвостом
     ((listp (first s)) (funcall (lambda (x) (append (union (first s) nil) x)) (f4 (rest s))))
     ; иначе, преобразуем первый эт-т в список и объединяем его с хвостом
     (t (funcall (lambda (x) (append (union (list (first s)) nil) x)) (f4 (rest s))))
    )
)
