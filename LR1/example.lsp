#|
Задача 1
Пусть l1 и l2 -списки. Напишите функцию, которая возвращала бы t, если
первые два элемента этих списков соответственно равны друг другу, и nil - в
противном случае (например, если длина одного из списков меньше 2).
|#

(defun f1(l1 l2)
    (and (> (length l1) 1) (> (length l2) 1)
    (equal (first l1) (first l2))
    (equal (second l1) (second l2))
    )
)


#|
Задача 2
Напишите функцию, зависящую от двух аргументов x и u, удаляющую все
вхождения x в список u на всех уровнях.
|#

(defun f2(x u)
    (if (null u) nil
     ; else
     (let ((c (first u)) (r (rest u)))
       (cond 
        ((and (atom c) (equal x c)) (f2 x r))
        ((atom c) (cons c (f x r)))
        (t (cons (f x c) (f x r)))
       )
     )
    )
)

#|
Задача 3
Сортировка слиянием. Даны два упорядоченных по возрастанию списка чи-
сел x и y. Написать функцию (merge x y), которая в качестве значения выдает
общий упорядоченный список элементов x и y. Например,
merge('(1 3 5 7 8) '(2 3 5 7)) => (1 2 3 3 5 5 7 7 8).
|#


(defun mymerge(x y)
    (cond
        ((null x) y)
        ((null y) x)
        ((> (first x) (first y))
            (cons (first y) (mymerge x (rest y)))
        )
        (t
            (cons (first x) (mymerge (rest x) y))
        )
    )
)
